#!/usr/bin/env python
# -*- coding: utf-8 -*-
import logging
import urllib

import tornado
from lxml import etree

from .base import BaseHandler
from ..utils import debug_wrapper, render_md_to_html, unquote_fr_mongo, utcnow
from ..const import LOG_NAME


log = logging.getLogger(LOG_NAME)


class AmendHandler(BaseHandler):
    """APIs about posts"""

    @tornado.web.authenticated
    @tornado.gen.coroutine
    @debug_wrapper
    def get(self):
        log.info('GET AmendHandler')
        post_name = self.get_argument('post-name', strip=True)
        post_name = urllib.parse.quote(post_name)
        log.debug('GET AmendHandler with post_name {}'.format(post_name))

        post = yield self.db.posts.find_one({'post_name': post_name})
        post = unquote_fr_mongo(post)
        if not post:
            raise tornado.httpclient.HTTPError(406, 'post-name not exists')

        self.render2('amend/index.html', post=post)
        self.finish()

    @tornado.web.authenticated
    @tornado.gen.coroutine
    @debug_wrapper
    def post(self):
        log.info('POST AmendHandler')
        post_title = self.get_argument('postTitle', strip=True)
        post_name = self.get_argument('postName', strip=True)
        post_name = urllib.parse.quote(post_name)
        post_content = self.get_argument('postContent')
        post_type = self.get_argument('postType', default='text')
        log.debug('POST AmendHandler for post_title {}, post_name {}, '
                  'post_content {}, post_type {}'
                  .format(post_title, post_name, post_content, post_type))

        # check existed
        docu = yield self.db.posts.find_one({'post_name': post_name})

        # author authorized
        if docu['post_author'] != self.current_user['_id']:
            log.warning('Unauthorized amend.')
            raise tornado.httpclient.HTTPError(401, 'Only owner can amend their post.')

        if post_type == 'slide':
            # extract slide body from the file generated by ipython nbconvert
            post_content = self.extract_reveal_html(post_content)
        elif post_type == 'markdown':
            # renfer github flavor markdown to html
            post_markdown = post_content
            post_content, post_menu = render_md_to_html(post_content, is_extract_menu=True)
        else:
            log.warning('unknown post_type: {}'.format(post_type))
            raise tornado.httpclient.HTTPError(406)

        docu = {
            # 'post_author': self.current_user['_id'],
            'post_modified_gmt': utcnow(),
            # 'post_status': 'publish',
            # 'comment_status': 'open',
            'post_title': post_title,
            # 'post_name': post_name,
            'post_content': post_content,
            'post_type': post_type,
            'post_menu': post_menu,
        }
        if post_type == 'markdown':
            docu.update({
                'post_markdown': post_markdown,
            })

        yield self.db.posts.update(
            {'post_name': post_name},
            {'$set': docu},
            upsert=True
        )

        self.write_json()

    def extract_reveal_html(self, html):
        log.debug('extract_reveal_html for html {}'.format(html))

        tree = etree.HTML(html.encode())
        node = tree.xpath('//div[@class="reveal"]')
        ret = etree.tostring(node[0]).decode()

        if '{{' in ret:
            return '{% raw %}' + ret + '{% endraw %}'
        else:
            return ret
